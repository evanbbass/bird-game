using System.IO; // For Path.Combine
using Sharpmake; // Contains the entire Sharpmake object library.

// Represents the project that will be generated by Sharpmake and that contains
// the sample C++ code.
[Generate]
public class BirdGameProject : Project
{
    public BirdGameProject()
    {
        // The name of the project in Visual Studio. The default is the name of
        // the class, but you usually want to override that.
        Name = "BirdGame";

        // The directory that contains the source code we want to build is the
        // same as this one. This string essentially means "the directory of
        // the script you're reading right now."
        SourceRootPath = Path.Combine("[project.SharpmakeCsPath]", "src");

        // Specify the targets for which we want to generate a configuration
        // for. Instead of creating multiple targets manually here, we can
        // use the binary OR operator to define multiple targets at once.
        // Sharpmake will generate all combinations possible and generate a
        // target for it.
        //
        // The code below is the same as creating 4 separate targets having
        // those flag combinations:
        //    * Platform.win32, DevEnv.vs2015, Optimization.Debug
        //    * Platform.win32, DevEnv.vs2015, Optimization.Release
        //    * Platform.win64, DevEnv.vs2015, Optimization.Debug
        //    * Platform.win64, DevEnv.vs2015, Optimization.Release
        AddTargets(new Target(
            // we want a target that builds for both 32 and 64-bit Windows.
            Platform.win32 | Platform.win64,

            // we only care about Visual Studio 2015. (Edit as needed.) (changed to 2022)
            DevEnv.vs2022,

            // of course, we want a debug and a release configuration.
            Optimization.Debug | Optimization.Release));
    }

	// Sets the properties of each configuration (conf) according to the target.
	//
	// This method is called once for every target specified by AddTargets. Since
	// we only want vs2015 targets and we want 32- and 64-bit targets, each having
	// a debug and a release version, we have 1 x 2 x 2 targets to configure, so it
	// will be called 4 times.
	//
	// If we had instead specified vs2012 | vs2015 | vs2017 it would have been
	// called 12 times. (3 x 2 x 2)
	[Configure]
	public void ConfigureAll(Project.Configuration conf, Target target)
	{
		conf.ProjectName = "BirdGame";

		// Specify where the generated project will be. Here we generate the
		// vcxproj in a /generated directory.
		conf.ProjectPath = Path.Combine("[project.SharpmakeCsPath]", "generated");

		// Add include path
		conf.IncludePaths.Add(Path.Combine("[project.SharpmakeCsPath]", "include"));

		conf.Options.Add(Options.Vc.General.CharacterSet.Unicode);
		conf.Options.Add(Options.Vc.General.WarningLevel.Level3);
		conf.Options.Add(Options.Vc.General.TreatWarningsAsErrors.Enable);
		conf.Options.Add(Options.Vc.General.WindowsTargetPlatformVersion.Latest);

		conf.Options.Add(Options.Vc.Compiler.CppLanguageStandard.CPP17);
		conf.Options.Add(Options.Vc.Compiler.Exceptions.Enable);

		conf.Options.Add(Options.Vc.Linker.SubSystem.Windows);
		conf.Options.Add(Options.Vc.Linker.LargeAddress.SupportLargerThan2Gb);
	}
}

// Represents the solution that will be generated and that will contain the
// project with the sample code.
[Generate]
public class BirdGameSolution : Solution
{
	public BirdGameSolution()
	{
		// The name of the solution.
		Name = "BirdGame";

		// As with the project, define which target this solution builds for.
		// It's usually the same thing.
		AddTargets(new Target(
			Platform.win32 | Platform.win64,
			DevEnv.vs2022,
			Optimization.Debug | Optimization.Release));
	}

	// Configure for all 4 generated targets. Note that the type of the
	// configuration object is of type Solution.Configuration this time.
	// (Instead of Project.Configuration.)
	[Configure]
	public void ConfigureAll(Solution.Configuration conf, Target target)
	{
		// Puts the generated solution in the /generated folder too.
		conf.SolutionPath = Path.Combine("[solution.SharpmakeCsPath]", "generated");

		// Adds the project described by BasicsProject into the solution.
		// Note that this is done in the configuration, so you can generate
		// solutions that contain different projects based on their target.
		//
		// You could, for example, exclude a project that only supports 64-bit
		// from the 32-bit targets.
		conf.AddProject<BirdGameProject>(target);
	}
}

public static class Main
{
	[Sharpmake.Main]
	public static void SharpmakeMain(Sharpmake.Arguments arguments)
	{
		// Tells Sharpmake to generate the solution described by
		// BasicsSolution.
		arguments.Generate<BirdGameSolution>();
	}
}
